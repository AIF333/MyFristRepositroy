-----------20180316-----------------
1.PYTHON学习：自我感觉是java和shell的组合，高级语言的再次抽象封装，更精简的代码编写，当然执行效率会低，但是更容易完成。
  （同样的功能，C可能1000行代码，java 100行，Python只需10行，效率C-0.001S java-0.01s  python-0.1s,但是整个网络受带宽影响1s
    所以 1.001 和 1.1 对于用户感知很低，当然对于速度要求特别高某些模块的直接用更底层的语言。）

2.字符编码问题  ASCII UNICODE UTF-8
  a.老美最开始发明 ASCII 码，一个字节（8bit），用其中的127个记录全部大小写英文字母和符号，完全满足美国人使用。
    随着计算机发展，各个国家都有自己的语言和文字，ASCII 码不够用，各国都有自己的文字编码，于是UNICODE编码出现.
  b.UNICODE一般采用两个字节，能表示的最多字符就是 2^16=40000+ ，特别生僻的就用4个字节。将各国的语言编码统一起来。
    这样彻底消除中文或其他非英语乱码问题。但是每个字符都用两个字节，真是大大的浪费存储空间，和影响传输速度，于是
    UTF-8编码出现。
  c.UTF-8采用可变长度编码（1-6个字节），英文和字符还都是一个字节（完美兼容ASCII码），汉字一般是3个字节，这样整个文件
    的存储更小，传输更快。
目前：文件在传送和保存在硬件上时一般都是UTF-8，在内存执行时一般是UNICODE

3.集合 分两个 list 和 tuple，区别list是可变集合，而tuple是不可变的，语法规范：
 li=[1,2,3,4,5] --list 中括号，可以删除内部元素或增加元素
 tu=(1,2,3,4,5) --tuple 定义时就必须赋值，不允许修改，注意特殊 tu=(1,2,li) ,li的内部元素是可以调整的，不可变指的是指向的li不变，
                --但li的内部元素是可以变的
 tu=(1,) --只有一个元素的tuple，后面的逗号不能去掉，消除歧义。tu=(1) 等价于 tu=1 ,变量赋值不是集合了。

4.字典，图，分两个： dict 和 set
  dict: 是<key,value>的集合，其中key是不可重复且不可变的（list就不能做key），能够通过key值快速定位到value（HASH算法）
        原理相当于字典的目录，典型的空间换时间，同list相比，存储消耗大。
  set：    是key的集合，内部元素是不可重复的，无value

  语法规范：
     di={'yeteng':13476152416,'yemao':13567891234} --大括号
     se=(['yeteng','yemao',1,2,3]) --小括号里面一个list，元素会自动剔重，不重复，可以做集合的交并运算 s1 & s2  s1 | S2


------------20180319-------------------------
1.generator  生成器
  背景：如果一个集合list有巨大的数据量，那么是非常耗费存储空间的。如果这个集合能够根据某种规则推到出来，
        不用全量存储，那是多么高效的事情。generator出来了。
  如 一个 x^2的集合
  L1=[ x * x for x in range(1000000) ]  -- 集合
  G1=( x * x for x in range(1000000) )  -- generator
  generator 通过 .next 或 for 方法调用。
  某些函数（如fabiacii数列）则使用关键字 yield

----------------20180922---------------------------------------------------
中文乱码问题：
print u"%s最大公约数是%s" % (in_value,v_count) #输出
file=raw_input(unicode('请输入要打开的文件:','utf-8').encode('gbk')) #输入
其中输入函数 raw_input 和 input区别：
raw_input 输入都当做字符串处理，会有强制转换如：num=int(raw_input('enter a number:'))
input则严格按照python规则来
  
-----------------20180923----------------------------------------------------
方法中 self.
变量前加self，则说明该变量是实例变量，实例中会覆盖类中同名全局变量
不加self则说明是一个局部变量，只在该方法中有效，不会影响类中的全局和其他类中的变量
  
-----------------20180924--------------------------------------------------------
>>> l=[ i for i in range(10)]  #列表推导
>>> l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> s={i for i in range(10) if i%3==0 } #集合推导 set，会剔重
>>> s
{0, 9, 3, 6}
>>> d={i:i%3==0 for i in range(10)} #字典推导
>>> d
{0: True, 1: False, 2: False, 3: True, 4: False, 5: False, 6: True, 7: False, 8: False, 9: True}
>>> t=(i for i in range(10) if i%3==0) #生成器推导
>>> t
<generator object <genexpr> at 0x000000000308E0F8>
>>> next(t)
0
>>> next(t)
3

------------------20180927-----------------------
python与别的语言稍有不同的语法，for/while 后面跟 else则是正常执行完的会执行else，break的则不执行，如：
while i <=10:
    print(i)
    i++
else:
    print("OK") ## OK 会在最后输出，如果while里是break退出的则不输出OK
    
--------------------20180928-----------------------
map(func,seq)         对序列中的所有元素执行函数
filter(func,seq)    返回一个列表，满足函数执行结果为True的
reduce(func,seq)    等价func(func(seq[0],seq[1]),seq[2]))...


-------------------20181015-------------------------------
类方法，静态方法，实例方法
class Example:
val1 = "Value 1"
def __init__(self):
self.val2 = "Value 2"
@staticmethod
def staticmd():
print("静态方法，无法访问Value1和Value2")
@classmethod
def classmd(cls):
print('类方法，类：'+str(cls)+",val1:"+cls.val1+",无法访问val2的值")
example = Example()
example.staticmd() #实例调用静态方法，无法访问实例变量val1和val2
example.classmd() #实例调用类方法，输出结果：类方法，类：<class '__main__.Example'>,val1:Value 1,无法访问val2的值
Example.classmd() #类调用类方法，输出结果：类方法，类：<class '__main__.Example'>,val1:Value 1,无法访问val2的值
example.val1 = "The instance value1 changed"
example.classmd() #类调用类方法，输出结果：类方法，类：<class '__main__.Example'>,val1:Value 1,无法访问val2的值
Example.val1 = "The class value2 changed"
example.classmd() #类调用类方法，输出结果：类方法，类：<class '__main__.Example'>,val1:The class value2 changed,无法访问val2的值
Example.classmd() #类调用类方法，输出结果：类方法，类：<class '__main__.Example'>,val1:The class value2 changed,无法访问val2的值

先是在语法上面的区别:
静态方法不需要传入self参数，类成员方法需要传入代表本类的cls参数；
静态方法是无妨访问实例变量和类变量的，类成员方法无法访问实例变量但是可以访问类变量
使用的区别：
由于静态方法无法访问类属性，实例属性，相当于一个相对独立的方法，跟类其实并没有什么关系。这样说来，静态方法就是在类的作用域里的函数而已。

举例：村庄类
具体的哪个村庄，有多少亩田地，多少户人，这些是根据实例对象定的，可以作为实例方法；
一共有多少个村子，村庄的统一建设口号，这种和村庄类相关，与实际某一个村子联系较小的可以作为类方法；
和类变量，实例变量相关度均较低的，则可以用静态方法，如 村庄所在的星球：地球 
  
------------------------------20181102---------------------------------------
类的方法名和属性名相同时，属性会覆盖方法！（常见错误）
  
------------------------------20181121--re正则表达式-------------------------
pat=re.compile(r'dc\n') r表明是原字符 \n 就是两个字符 \ n
 其他的 \d 是数字
  
------------------------------20181124--decode/encode--------------------------
字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。

decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode('gb2312')，表示将gb2312编码的字符串str1转换成unicode编码。
encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode('gb2312')，表示将unicode编码的字符串str2转换成gb2312编码。

  
------------------------------20181127--json---------------------------
json 轻量级数据传输器，四个基本规则：
1.并列的数据用 ','
2.映射用 ':'
3.并列的数据集合用 '[]'
4.对象用 '{}'

如 北京市的面积100000平方公里，常住人口1500W；上海市面积110000平方公里，常住人口1600W
转换成json：
[{'城市':'北京','面积':'100000','人口':'1500W'},{'城市':'上海','面积':'110000','人口':'1600W'}]

------------------------20181213-----------------------------------------------------------------
redis作为一个轻量级的键值对内存数据库，能够高速读取的原因就是因为考虑的东西少。oracle需要考虑缓存与物理库的
数据一致性，会涉及到redo,undo,锁，而redis则完全不需要，故速度上来了。
因此
1.redis也不可能有很高的数据完整性，需要应用层能容许少量数据丢失。
2.作为内存库，从读取性能应只考虑将少量的热点数据放入redis中，而不能将常规数据，甚至图片，视频等放入。

数据类型：
字符串-有序不可变
数值类型-不可变
列表list-有序可变
元组tuple-有序不可变
集合set-无序可变但不重复
字典dict-无序可变的键值对集合

硬盘只认识二进制和字符串，像字典，集合，元组，甚至类，方法等带有编程语言内部环境的需序列化才能记录在硬盘。
python中 pickle模块进行序列化（能将普通的字符串，列表，字典以及类，方法都进行序列化）
而通用的软件序列化是json，但只能序列化普通的，不能序列化类，函数等。
在90年代为了解决linux和Windows中的数据无法交换问题，引入了XML（两大平台均遵守该规则），但是xml会增大数据体，如10M文件转XML可能需要
15M，包括5M的解释，后来json出现，逐步取代xml

XML 被设计用来传输和存储数据。
HTML 被设计用来显示数据。
http://www.w3school.com.cn/xml/xml_intro.asp


python里的装饰期，即函数里面包函数，能执行成功的关键是 return的是函数地址，而不是执行函数。
比如定义一个查看函数运行时间的装饰期runtime：

def runtime(func):
	def inner():
		start=time.localtime()
		func() #inner加了括号 函数会调用func
		end=time.localtime()
		printf("程序运行时间为：",end-start)
	return inner #没加括号则不会调用，返回inner的函数地址
	
	
则会运行本来的 sayHello函数然后给出时间，装饰期的好处在于可以不改变源程序的代码和执行方式，
比如我们根本不用关心 sayHello函数怎么写的，就能正常运行并给出运行时间，即使有成千上万个程序
需要添加都能不改变原有的运行和代码块实现。
@runtime
sayHello()

等价于：
	
sayHello=runtime(sayHello)
sayHello()



---------------------


